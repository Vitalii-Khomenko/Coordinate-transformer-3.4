<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Coordinate Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.4.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@v7.4.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .tabs {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            margin-bottom: 20px;
            gap: 10px;
            justify-content: flex-start;
        }
        .tab {
            display: inline-block;
            background: #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
            padding: 6px 16px;
            margin: 0;
            min-width: 0;
            min-height: 0;
            border: none;
            transition: background 0.2s, color 0.2s;
            text-align: center;
            line-height: 1.2;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
        }
        @media (max-width: 900px) {
            .tabs {
                flex-direction: column;
                gap: 4px;
                align-items: stretch;
            }
            .tab {
                width: 100%;
                font-size: 14px;
                padding: 6px 0;
                min-width: 0;
                min-height: 0;
                border-radius: 4px;
                margin: 0;
                box-sizing: border-box;
            }
        }
        @media (max-width: 600px) {
            .tab {
                font-size: 13px;
                padding: 5px 0;
            }
        }
        .input-form {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .form-group {
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .input-description {
            margin-bottom: 8px;
            font-size: 1.08em;
            color: #333;
            text-align: left;
        }
        textarea {
            width: 100%;
            min-width: 0;
            resize: vertical;
            font-size: 1em;
            font-family: monospace;
            box-sizing: border-box;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 0;
        }
        button {
            flex: 1 1 160px;
            min-width: 120px;
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #45a049;
        }
        button.save-txt {
            background: #2196F3;
        }
        button.save-txt:hover {
            background: #1976D2;
        }
        button.save-pdf {
            background: #f44336;
        }
        button.save-pdf:hover {
            background: #d32f2f;
        }
        button.import-txt {
            background: #9C27B0;
        }
        button.import-txt:hover {
            background: #7B1FA2;
        }
        button.reverse-convert {
            background: #607D8B;
        }
        button.reverse-convert:hover {
            background: #455A64;
        }
        #fileInput {
            display: none;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f5f5f5;
        }
        tr:hover {
            background-color: #f9f9f9;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .map-link {
            color: #4CAF50;
            text-decoration: none;
        }
        .map-link:hover {
            text-decoration: underline;
        }
        #map {
            width: 100%;
            height: 600px;
            margin-top: 20px;
        }
        .map-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        #mapContainer {
            width: 100%;
            height: 600px;
            overflow: hidden;
        }
        .ol-viewport {
            overflow: hidden !important;
        }
        .ol-overlay-container {
            overflow: hidden !important;
        }
        .ol-canvas {
            overflow: hidden !important;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        @media (min-width: 600px) {
            .input-form {
                min-width: 340px;
            }
            .form-group {
                flex-direction: column;
                align-items: stretch;
            }
            textarea {
                min-height: 120px;
                height: 2.5em;
                max-height: 350px;
            }
        }
        @media (min-width: 900px) {
            .input-form {
                min-width: 500px;
            }
            textarea {
                min-height: 160px;
                height: 3.5em;
                max-height: 400px;
            }
        }
        @media (max-width: 900px) {
            .container {
                padding: 0 5px;
            }
            .tabs {
                flex-direction: column;
                gap: 5px;
            }
            .tab {
                min-width: 100px;
                padding: 10px 0;
            }
            .button-group {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 6px;
                justify-content: flex-start;
            }
            button {
                width: auto;
                min-width: 80px;
                font-size: 14px;
                padding: 8px 10px;
                margin: 0;
                flex: 1 1 120px;
            }
            #gk2wgs textarea, #wgs2gk textarea {
                min-height: 100px;
                height: 120px;
                max-height: 200px;
            }
        }
        @media (max-width: 600px) {
            .input-form, .map-container {
                padding: 10px;
            }
            table, th, td {
                font-size: 13px;
                padding: 6px;
            }
            #mapContainer {
                height: 300px;
            }
            .button-group {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
                justify-content: flex-start;
            }
            button {
                width: auto;
                min-width: 60px;
                font-size: 13px;
                padding: 7px 7px;
                margin: 0;
                flex: 1 1 90px;
            }
        }
        @media (max-width: 768px) {
            body {
                margin: 10px;
            }
            .container {
                width: 100%;
                padding: 0;
            }
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
            th, td {
                padding: 8px;
                font-size: 14px;
            }
            #map {
                height: 400px;
            }
        }
        @media (hover: none) {
            button, input[type="text"], textarea, .tab {
                min-height: 44px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Universal Coordinate Converter</h1>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('gk2wgs')">Gauß-Krüger (Bessel, Potsdam) to Dezimalgrad (WGS84)</div>
            <div class="tab" onclick="switchTab('wgs2gk')">WGS84 → Target System</div>
            <div class="tab" onclick="switchTab('sweref2wgs')">SWEREF99 18 00 → WGS84</div>
            <div class="tab" onclick="switchTab('map')">Map</div>
        </div>

        <div id="gk2wgs" class="tab-content active">
            <div class="input-form">
                <div class="form-group">
                    <div class="input-description">Enter: <b>PointID Easting Northing Height</b> (Gauss-Krüger, Bessel)</div>
                    <textarea id="coordinates" rows="10" placeholder="Example:\n1029 3568189.267 5657692.868 321.609"></textarea>
                </div>
                <div class="button-group">
                    <button onclick="convertCoordinates()">Convert</button>
                    <button onclick="clearInput()" class="save-txt">Clear Input</button>
                    <button onclick="document.getElementById('fileInput').click()" class="import-txt">Import TXT</button>
                    <button onclick="saveToTxt()" class="save-txt">Save as TXT</button>
                    <button onclick="saveToPdf()" class="save-pdf">Save as PDF</button>
                </div>
                <input type="file" id="fileInput" accept=".txt" style="display:none" onchange="handleFileImport(event)">
            </div>
            <table id="resultsTable">
                <thead>
                    <tr>
                        <th>PointID</th>
                        <th>Easting (GK)</th>
                        <th>Northing (GK)</th>
                        <th>Height</th>
                        <th>Latitude (WGS84)</th>
                        <th>Longitude (WGS84)</th>
                        <th>Google Maps</th>
                    </tr>
                </thead>
                <tbody id="resultsBody">
                </tbody>
            </table>
        </div>

        <div id="wgs2gk" class="tab-content">
            <div class="input-form">
                <div class="form-group">
                    <div class="input-description">Enter: <b>PointID Latitude Longitude</b> (WGS84)</div>
                    <textarea id="wgsCoordinates" rows="10" placeholder="Example:\n1029 51.05031687 9.971396507"></textarea>
                </div>
                <div class="form-group">
                    <label for="targetSystem">Target Coordinate System:</label>
                    <select id="targetSystem" style="padding: 5px; margin: 5px; border: 1px solid #ccc; border-radius: 4px;">
                        <option value="gk">Gauß-Krüger (GK)</option>
                        <option value="sweref99">SWEREF99 18 00</option>
                    </select>
                </div>
                <div class="button-group">
                    <button onclick="convertWGS84ToTarget()" class="reverse-convert">Convert</button>
                    <button onclick="clearWGSInput()" class="save-txt">Clear Input</button>
                    <button onclick="document.getElementById('wgsFileInput').click()" class="import-txt">Import TXT</button>
                    <button onclick="saveWGS84ToTxt()" class="save-txt">Save as TXT</button>
                    <button onclick="saveWGS84ToPdf()" class="save-pdf">Save as PDF</button>
                </div>
                <input type="file" id="wgsFileInput" accept=".txt" style="display:none" onchange="handleWGSFileImport(event)">
            </div>
            <table id="wgsResultsTable">
                <thead>
                    <tr>
                        <th>PointID</th>
                        <th>Latitude (WGS84)</th>
                        <th>Longitude (WGS84)</th>
                        <th id="eastingHeader">Easting</th>
                        <th id="northingHeader">Northing</th>
                    </tr>
                </thead>
                <tbody id="wgsResultsBody">
                </tbody>
            </table>
        </div>

        <div id="sweref2wgs" class="tab-content">
            <div class="input-form">
                <div class="form-group">
                    <div class="input-description">Enter: <b>PointID Easting Northing Height</b> (SWEREF99 18 00, EPSG:3011)</div>
                    <textarea id="swerefCoordinates" rows="10" placeholder="Example:\n1029 674189.267 6557692.868 321.609"></textarea>
                </div>
                <div class="button-group">
                    <button onclick="convertSwerfToWGS84()">Convert</button>
                    <button onclick="clearSwerefInput()" class="save-txt">Clear Input</button>
                    <button onclick="document.getElementById('swerefFileInput').click()" class="import-txt">Import TXT</button>
                    <button onclick="saveSwerefToTxt()" class="save-txt">Save as TXT</button>
                    <button onclick="saveSwerefToPdf()" class="save-pdf">Save as PDF</button>
                </div>
                <input type="file" id="swerefFileInput" accept=".txt" style="display:none" onchange="handleSwerefFileImport(event)">
            </div>
            <table id="swerefResultsTable">
                <thead>
                    <tr>
                        <th>PointID</th>
                        <th>Easting (SWEREF99)</th>
                        <th>Northing (SWEREF99)</th>
                        <th>Height</th>
                        <th>Latitude (WGS84)</th>
                        <th>Longitude (WGS84)</th>
                        <th>Google Maps</th>
                    </tr>
                </thead>
                <tbody id="swerefResultsBody">
                </tbody>
            </table>
        </div>

        <div id="map" class="tab-content">
            <div class="map-container">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
                    <button onclick="saveMapToPdf()" class="save-pdf">Save Map as PDF</button>
                    <button onclick="exportKML()" class="save-txt">Export as KML</button>
                    <label for="pdfQuality" style="font-weight:normal;">JPEG quality:</label>
                    <input type="range" id="pdfQuality" min="0.2" max="1" step="0.05" value="0.7" style="width:120px;">
                    <span id="pdfQualityValue">0.7</span>
                </div>
                <div id="mapContainer" style="width: 100%; height: 600px;"></div>
            </div>
        </div>
    </div>

    <script>
        function pot2wgs(lng, lat) {
            var dx = 598.1, dy = 73.7, dz = 418.2;
            var rx = 0.202 / 3600 * Math.PI / 180;
            var ry = 0.045 / 3600 * Math.PI / 180;
            var rz = -2.455 / 3600 * Math.PI / 180;
            var m = 6.7 / 1e6;
            var a = 6377397.15508;
            var f = 3.34277321e-3;
            var e2 = 2*f - f*f;
            var latRad = lat * Math.PI / 180;
            var lngRad = lng * Math.PI / 180;
            var N = a / Math.sqrt(1 - e2 * Math.sin(latRad) * Math.sin(latRad));
            var X = N * Math.cos(latRad) * Math.cos(lngRad);
            var Y = N * Math.cos(latRad) * Math.sin(lngRad);
            var Z = N * (1 - e2) * Math.sin(latRad);
            var X2 = X + dx + m*X - rz*Y + ry*Z;
            var Y2 = Y + dy + rz*X + m*Y - rx*Z;
            var Z2 = Z + dz - ry*X + rx*Y + m*Z;
            var a2 = 6378137.0;
            var f2 = 1 / 298.257223563;
            var e22 = 2*f2 - f2*f2;
            var p = Math.sqrt(X2*X2 + Y2*Y2);
            var lat2 = Math.atan2(Z2, p * (1 - e22));
            var lat2old;
            do {
                lat2old = lat2;
                var N2 = a2 / Math.sqrt(1 - e22 * Math.sin(lat2old) * Math.sin(lat2old));
                lat2 = Math.atan2(Z2 + e22*N2*Math.sin(lat2old), p);
            } while (Math.abs(lat2 - lat2old) > 1e-11);
            var lng2 = Math.atan2(Y2, X2);
            return { lat: lat2 * 180/Math.PI, lng: lng2 * 180/Math.PI };
        }

        function gk2geo(rw, hw) {
            var ll = {};
            if (rw == "" || hw == "" || isNaN(rw) || isNaN(hw)) return ll;
            rw = parseFloat(rw);
            hw = parseFloat(hw);
            var a = 6377397.15508;
            var f = 3.34277321e-3;
            var pi = Math.PI;
            var c = a/(1-f);
            var ex2 = (2*f-f*f)/((1-f)*(1-f));
            var ex4 = ex2*ex2;
            var ex6 = ex4*ex2;
            var ex8 = ex4*ex4;
            var e0 = c*(pi/180)*(1 - 3*ex2/4 + 45*ex4/64 - 175*ex6/256 + 11025*ex8/16384);
            var f2 =   (180/pi)*(    3*ex2/8 - 3*ex4/16  + 213*ex6/2048 -  255*ex8/4096);
            var f4 =              (180/pi)*(  21*ex4/256 -  21*ex6/256  +  533*ex8/8192);
            var f6 =                           (180/pi)*(  151*ex6/6144 -  453*ex8/12288);
            var sigma = hw/e0;
            var sigmr = sigma*pi/180;
            var bf = sigma + f2*Math.sin(2*sigmr) + f4*Math.sin(4*sigmr) + f6*Math.sin(6*sigmr);
            var br = bf * pi/180;
            var tan1 = Math.tan(br);
            var tan2 = tan1*tan1;
            var tan4 = tan2*tan2;
            var cos1 = Math.cos(br);
            var cos2 = cos1*cos1;
            var etasq = ex2*cos2;
            var nd = c/Math.sqrt(1 + etasq);
            var nd2 = nd*nd;
            var nd4 = nd2*nd2;
            var nd6 = nd4*nd2;
            var nd3 = nd2*nd;
            var nd5 = nd4*nd;
            var kz = parseInt(rw/1e6);
            var lh = kz*3;
            var dy = rw-(kz*1e6+500000);
            var dy2 = dy*dy;
            var dy4 = dy2*dy2;
            var dy3 = dy2*dy;
            var dy5 = dy4*dy;
            var dy6 = dy3*dy3;
            var b2 = - tan1*(1+etasq)/(2*nd2);
            var b4 =   tan1*(5+3*tan2+6*etasq*(1-tan2))/(24*nd4);
            var b6 = - tan1*(61+90*tan2+45*tan4)/(720*nd6);
            var l1 =   1/(nd*cos1);
            var l3 = - (1+2*tan2+etasq)/(6*nd3*cos1);
            var l5 =   (5+28*tan2+24*tan4)/(120*nd5*cos1);
            var lat = bf + (180/pi) * (b2*dy2 + b4*dy4 + b6*dy6);
            var lng = lh + (180/pi) * (l1*dy  + l3*dy3 + l5*dy5);
            var llw = pot2wgs(lng, lat);
            return llw;
        }

        function Dezimal2GK(lp, bp) {
            var gk = {};
            if (lp === "" || bp === "" || isNaN(lp) || isNaN(bp)) return gk;
            lp = parseFloat(lp);
            bp = parseFloat(bp);
            if (bp < 46 || bp > 56 || lp < 5 || lp > 16) {
                return gk;
            }
            var a = 6377397.15508;
            var f = 3.34277321e-3;
            var pi = Math.PI;
            var c = a / (1 - f);
            var ex2 = (2 * f - f * f) / ((1 - f) * (1 - f));
            var ex4 = ex2 * ex2;
            var ex6 = ex4 * ex2;
            var ex8 = ex4 * ex4;
            var e0 = c * (pi / 180) * (1 - 3 * ex2 / 4 + 45 * ex4 / 64 - 175 * ex6 / 256 + 11025 * ex8 / 16384);
            var e2 = c * (-3 * ex2 / 8 + 15 * ex4 / 32 - 525 * ex6 / 1024 + 2205 * ex8 / 4096);
            var e4 = c * (15 * ex4 / 256 - 105 * ex6 / 1024 + 2205 * ex8 / 16384);
            var e6 = c * (-35 * ex6 / 3072 + 315 * ex8 / 12288);
            var br = bp * pi / 180;
            var tan1 = Math.tan(br);
            var tan2 = tan1 * tan1;
            var tan4 = tan2 * tan2;
            var cos1 = Math.cos(br);
            var cos2 = cos1 * cos1;
            var cos4 = cos2 * cos2;
            var cos3 = cos2 * cos1;
            var cos5 = cos4 * cos1;
            var etasq = ex2 * cos2;
            var nd = c / Math.sqrt(1 + etasq);
            var g = e0 * bp + e2 * Math.sin(2 * br) + e4 * Math.sin(4 * br) + e6 * Math.sin(6 * br);
            var kz = parseInt((lp + 1.5) / 3);
            var lh = kz * 3;
            var dl = (lp - lh) * pi / 180;
            var dl2 = dl * dl;
            var dl4 = dl2 * dl2;
            var dl3 = dl2 * dl;
            var dl5 = dl4 * dl;
            var hw = g + nd * cos2 * tan1 * dl2 / 2 + nd * cos4 * tan1 * (5 - tan2 + 9 * etasq) * dl4 / 24;
            var rw = nd * cos1 * dl + nd * cos3 * (1 - tan2 + etasq) * dl3 / 6 + nd * cos5 * (5 - 18 * tan2 + tan4) * dl5 / 120 + kz * 1e6 + 500000;
            gk["h"] = hw.toFixed(3);
            gk["r"] = rw.toFixed(3);
            gk["z"] = rw.toString().charAt(0);
            return gk;
        }

        function wgs2pot(lp, bp) {
            var ll = [];
            if (lp === "" || bp === "" || isNaN(lp) || isNaN(bp)) return ll;
            lp = parseFloat(lp);
            bp = parseFloat(bp);

            var a = 6378137.000 - 739.845;
            var fq = 3.35281066e-3 - 1.003748e-05;
            var f = 3.35281066e-3;

            var dx = -587;
            var dy = -16;
            var dz = -393;

            var e2q = (2 * fq - fq * fq);
            var e2 = (2 * f - f * f);
            var pi = Math.PI;
            var b1 = bp * (pi / 180);
            var l1 = lp * (pi / 180);
            var nd = a / Math.sqrt(1 - e2 * Math.sin(b1) * Math.sin(b1));

            var x = nd * Math.cos(b1) * Math.cos(l1);
            var y = nd * Math.cos(b1) * Math.sin(l1);
            var z = (1 - e2) * nd * Math.sin(b1);

            var xp = x + dx;
            var yp = y + dy;
            var zp = z + dz;

            var rb = Math.sqrt(xp * xp + yp * yp);
            var b2 = (180 / pi) * Math.atan((zp / rb) / (1 - e2q));
            var l2 = 0;
            if (xp > 0)
                l2 = (180 / pi) * Math.atan(yp / xp);
            if (xp < 0 && yp > 0)
                l2 = (180 / pi) * Math.atan(yp / xp) + 180;
            if (xp < 0 && yp < 0)
                l2 = (180 / pi) * Math.atan(yp / xp) - 180;

            ll["lng"] = parseFloat(l2.toFixed(8));
            ll["lat"] = parseFloat(b2.toFixed(8));
            return ll;
        }

        // Mathematical helper functions for older browser compatibility
        Math.cosh = Math.cosh || function(x) {
            return (Math.exp(x) + Math.exp(-x)) / 2;
        };
        
        Math.sinh = Math.sinh || function(x) {
            return (Math.exp(x) - Math.exp(-x)) / 2;
        };
        
        Math.tanh = Math.tanh || function(x) {
            var exp2x = Math.exp(2 * x);
            return (exp2x - 1) / (exp2x + 1);
        };
        
        Math.asinh = Math.asinh || function(x) {
            return Math.log(x + Math.sqrt(x * x + 1));
        };
        
        Math.atanh = Math.atanh || function(x) {
            return 0.5 * Math.log((1 + x) / (1 - x));
        };

        // SWEREF99 18 00 to WGS84 conversion functions - Built-in Mathematical Implementation
        function sweref99ToWGS84(easting, northing) {
            // SWEREF99 18 00 parameters (EPSG:3011)
            var a = 6378137.0;              // Semi-major axis (GRS80)
            var f = 1 / 298.257222101;      // Flattening (GRS80)
            var lat0 = 0.0;                 // Latitude of natural origin (degrees)
            var lon0 = 18.0;                // Longitude of natural origin (degrees)
            var k0 = 1.0;                   // Scale factor at natural origin
            var x0 = 150000.0;              // False easting (meters)
            var y0 = 0.0;                   // False northing (meters)
            
            // Convert to radians
            var DEG_TO_RAD = Math.PI / 180.0;
            var RAD_TO_DEG = 180.0 / Math.PI;
            
            lat0 *= DEG_TO_RAD;
            lon0 *= DEG_TO_RAD;
            
            // Derived constants
            var b = a * (1 - f);           // Semi-minor axis
            var e2 = 2 * f - f * f;        // First eccentricity squared
            var e = Math.sqrt(e2);         // First eccentricity
            var e1 = (1 - Math.sqrt(1 - e2)) / (1 + Math.sqrt(1 - e2));
            
            // Remove false easting and northing
            var x = easting - x0;
            var y = northing - y0;
            
            // Calculate meridional arc
            var M0 = 0; // M0 = 0 since lat0 = 0
            var M = M0 + y / k0;
            
            // Calculate footprint latitude
            var mu = M / (a * (1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256));
            
            var e1_2 = e1 * e1;
            var e1_3 = e1_2 * e1;
            var e1_4 = e1_3 * e1;
            
            var fp = mu + (3*e1/2 - 27*e1_3/32) * Math.sin(2*mu) 
                       + (21*e1_2/16 - 55*e1_4/32) * Math.sin(4*mu)
                       + (151*e1_3/96) * Math.sin(6*mu)
                       + (1097*e1_4/512) * Math.sin(8*mu);
            
            // Calculate radius of curvature
            var sin_fp = Math.sin(fp);
            var cos_fp = Math.cos(fp);
            var tan_fp = Math.tan(fp);
            var tan2_fp = tan_fp * tan_fp;
            var tan4_fp = tan2_fp * tan2_fp;
            
            var n1 = a / Math.sqrt(1 - e2 * sin_fp * sin_fp);
            var r1 = a * (1 - e2) / Math.pow(1 - e2 * sin_fp * sin_fp, 1.5);
            var d = x / (n1 * k0);
            var d2 = d * d;
            var d3 = d2 * d;
            var d4 = d3 * d;
            var d5 = d4 * d;
            var d6 = d5 * d;
            
            var c1 = e2 * cos_fp * cos_fp / (1 - e2);
            var c1_2 = c1 * c1;
            
            // Calculate latitude
            var lat = fp - (n1 * tan_fp / r1) * (d2/2 - (5 + 3*tan2_fp + 10*c1 - 4*c1_2 - 9*e2*cos_fp*cos_fp) * d4/24
                      + (61 + 90*tan2_fp + 298*c1 + 45*tan4_fp - 252*e2*cos_fp*cos_fp - 3*c1_2) * d6/720);
            
            // Calculate longitude
            var lon = lon0 + (d - (1 + 2*tan2_fp + c1) * d3/6 
                           + (5 - 2*c1 + 28*tan2_fp - 3*c1_2 + 8*e2*cos_fp*cos_fp + 24*tan4_fp) * d5/120) / cos_fp;
            
            // Convert to degrees
            return {
                lat: lat * RAD_TO_DEG,
                lng: lon * RAD_TO_DEG
            };
        }

        // WGS84 to SWEREF99 18 00 conversion - Built-in Mathematical Implementation
        function wgs84ToSweref99(lat, lng) {
            // SWEREF99 18 00 parameters (EPSG:3011)
            var a = 6378137.0;              // Semi-major axis (GRS80)
            var f = 1 / 298.257222101;      // Flattening (GRS80)
            var lat0 = 0.0;                 // Latitude of natural origin (degrees)
            var lon0 = 18.0;                // Longitude of natural origin (degrees)
            var k0 = 1.0;                   // Scale factor at natural origin
            var x0 = 150000.0;              // False easting (meters)
            var y0 = 0.0;                   // False northing (meters)
            
            // Convert to radians
            var DEG_TO_RAD = Math.PI / 180.0;
            
            lat *= DEG_TO_RAD;
            lng *= DEG_TO_RAD;
            lat0 *= DEG_TO_RAD;
            lon0 *= DEG_TO_RAD;
            
            // Derived constants
            var b = a * (1 - f);           // Semi-minor axis
            var e2 = 2 * f - f * f;        // First eccentricity squared
            var e = Math.sqrt(e2);         // First eccentricity
            
            // Calculate radius of curvature in the prime vertical
            var sin_lat = Math.sin(lat);
            var cos_lat = Math.cos(lat);
            var tan_lat = Math.tan(lat);
            var tan2_lat = tan_lat * tan_lat;
            var tan4_lat = tan2_lat * tan2_lat;
            
            var n = a / Math.sqrt(1 - e2 * sin_lat * sin_lat);
            var c = e2 * cos_lat * cos_lat / (1 - e2);
            var c2 = c * c;
            var a2 = (lng - lon0) * cos_lat;
            var a2_2 = a2 * a2;
            var a2_3 = a2_2 * a2;
            var a2_4 = a2_3 * a2;
            var a2_5 = a2_4 * a2;
            var a2_6 = a2_5 * a2;
            
            // Calculate meridional arc
            var M0 = 0; // M0 = 0 since lat0 = 0
            var M = a * ((1 - e2/4 - 3*e2*e2/64 - 5*e2*e2*e2/256) * lat
                       - (3*e2/8 + 3*e2*e2/32 + 45*e2*e2*e2/1024) * Math.sin(2*lat)
                       + (15*e2*e2/256 + 45*e2*e2*e2/1024) * Math.sin(4*lat)
                       - (35*e2*e2*e2/3072) * Math.sin(6*lat));
            
            // Calculate coordinates
            var x = k0 * n * (a2 + (1 - tan2_lat + c) * a2_3 / 6
                           + (5 - 18*tan2_lat + tan4_lat + 72*c - 58*e2*cos_lat*cos_lat) * a2_5 / 120);
            
            var y = k0 * (M - M0 + n * tan_lat * (a2_2/2 + (5 - tan2_lat + 9*c + 4*c2) * a2_4/24
                          + (61 - 58*tan2_lat + tan4_lat + 600*c - 330*e2*cos_lat*cos_lat) * a2_6/720));
            
            return {
                x: x + x0,
                y: y + y0
            };
        }

        function convertSwerfToWGS84() {
            const input = document.getElementById('swerefCoordinates').value;
            const lines = input.trim().split('\n');
            const resultsBody = document.getElementById('swerefResultsBody');
            resultsBody.innerHTML = '';
            
            let errorMessage = '';
            let errorCount = 0;
            
            lines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) return;
                
                const parts = trimmed.split(/\s+/);
                if (parts.length < 4) {
                    errorMessage += `Line ${idx+1}: Not enough values (expected PointID Easting Northing Height)\n`;
                    errorCount++;
                    return;
                }
                
                const [pointID, x, y, height] = parts;
                const xNum = parseFloat(x);
                const yNum = parseFloat(y);
                const hNum = parseFloat(height);
                
                if (!isFinite(xNum) || !isFinite(yNum) || !isFinite(hNum)) {
                    errorMessage += `Line ${idx+1}: Invalid number(s)\n`;
                    errorCount++;
                    return;
                }
                
                try {
                    const { lat, lng } = sweref99ToWGS84(xNum, yNum);
                    
                    if (!isFinite(lat) || !isFinite(lng)) {
                        errorMessage += `Line ${idx+1}: Conversion failed - invalid result\n`;
                        errorCount++;
                        return;
                    }
                    
                    const row = document.createElement('tr');
                    const mapsLink = getGoogleMapsLink(lat, lng);
                    
                    row.innerHTML = `
                        <td>${pointID}</td>
                        <td>${xNum.toFixed(3)}</td>
                        <td>${yNum.toFixed(3)}</td>
                        <td>${hNum.toFixed(3)}</td>
                        <td>${lat.toFixed(6)}</td>
                        <td>${lng.toFixed(6)}</td>
                        <td><a href="${mapsLink}" target="_blank" class="map-link">View on Map</a></td>
                    `;
                    resultsBody.appendChild(row);
                } catch (error) {
                    errorMessage += `Line ${idx+1}: Error converting coordinates: ${error && error.message ? error.message : error}\n`;
                    errorCount++;
                }
            });
            
            if (errorCount > 0) {
                alert('Errors found during conversion:\n\n' + errorMessage);
            }
            
            // Update map if available
            if (typeof initMap === 'function') {
                initMap();
            }
            if (typeof updateMap === 'function') {
                updateSwerefMap();
            }
        }

        function clearSwerefInput() {
            document.getElementById('swerefCoordinates').value = '';
            document.getElementById('swerefResultsBody').innerHTML = '';
        }

        function handleSwerefFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.match('text/plain')) {
                alert('Please select a text file (.txt)');
                event.target.value = '';
                return;
            }
            
            if (file.size > 5 * 1024 * 1024) {
                alert('File too large. Maximum size: 5MB');
                event.target.value = '';
                return;
            }
            
            lastImportedTxtFileName = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('swerefCoordinates').value = e.target.result;
            };
            reader.onerror = function() {
                alert('Error reading file');
                event.target.value = '';
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function saveSwerefToTxt() {
            const rows = document.querySelectorAll('#swerefResultsBody tr');
            if (!rows.length) {
                alert('No data to save.');
                return;
            }
            
            let content = 'PointID\tEasting_SWEREF99\tNorthing_SWEREF99\tHeight\tLatitude_WGS84\tLongitude_WGS84\n';
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 6) {
                    content += `${cells[0].textContent}\t${cells[1].textContent}\t${cells[2].textContent}\t${cells[3].textContent}\t${cells[4].textContent}\t${cells[5].textContent}\n`;
                }
            });
            
            let fileName = 'sweref99_to_wgs84_results.txt';
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, '_converted.txt');
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                fileName = `sweref99_results_${dd}${mm}${yyyy}.txt`;
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function saveSwerefToPdf() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
            
            const rows = document.querySelectorAll('#swerefResultsBody tr');
            if (!rows.length) {
                alert('No data to export.');
                return;
            }
            
            const tableData = [];
            const headers = ['PointID', 'Easting (SWEREF99)', 'Northing (SWEREF99)', 'Height', 'Latitude (WGS84)', 'Longitude (WGS84)', 'Google Maps'];
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 7) {
                    let gmaps = '';
                    const link = cells[6].querySelector('a');
                    if (link) {
                        gmaps = link.href; // Full clickable URL
                    }
                    tableData.push([
                        cells[0].textContent,
                        cells[1].textContent,
                        cells[2].textContent,
                        cells[3].textContent,
                        cells[4].textContent,
                        cells[5].textContent,
                        gmaps
                    ]);
                }
            });
            
            doc.autoTable({
                head: [headers],
                body: tableData,
                styles: { fontSize: 8 },
                columnStyles: {
                    0: { cellWidth: 20 },
                    1: { cellWidth: 28 },
                    2: { cellWidth: 28 },
                    3: { cellWidth: 20 },
                    4: { cellWidth: 28 },
                    5: { cellWidth: 28 },
                    6: { cellWidth: 128 }
                },
                margin: { left: 10, right: 10, top: 20, bottom: 20 }
            });
            
            let fileName = 'sweref99_to_wgs84_results.pdf';
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, '_converted.pdf');
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                fileName = `sweref99_results_${dd}${mm}${yyyy}.pdf`;
            }
            
            doc.save(fileName);
        }

        function updateSwerefMap() {
            if (!map || !vectorSource) return;
            
            vectorSource.clear();
            const rows = document.querySelectorAll('#swerefResultsBody tr');
            let features = [];
            let points = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 6) return;
                
                const pointID = cells[0].textContent.trim();
                const lat = parseFloat(cells[4].textContent);
                const lng = parseFloat(cells[5].textContent);
                
                if (!isFinite(lat) || !isFinite(lng)) return;
                points.push({ pointID, lat, lng });
            });
            
            if (points.length > 0) {
                features = points.map(pt => {
                    const pointFeature = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat([pt.lng, pt.lat]))
                    });
                    pointFeature.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: '#4CAF50' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                        })
                    }));
                    
                    const textFeature = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat([pt.lng, pt.lat]))
                    });
                    textFeature.setStyle(new ol.style.Style({
                        text: new ol.style.Text({
                            text: pt.pointID,
                            font: 'bold 13px Arial',
                            fill: new ol.style.Fill({ color: '#FF9800' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                            offsetY: -18
                        })
                    }));
                    
                    vectorSource.addFeature(pointFeature);
                    vectorSource.addFeature(textFeature);
                    return [pointFeature, textFeature];
                });
                
                map.getView().setCenter(ol.proj.fromLonLat([points[0].lng, points[0].lat]));
                map.getView().setZoom(13);
            } else {
                map.getView().setCenter(ol.proj.fromLonLat([10.0, 51.0]));
                map.getView().setZoom(6);
            }
        }

        function convertWGS84ToTarget() {
            const targetSystem = document.getElementById('targetSystem').value;
            const input = document.getElementById('wgsCoordinates').value;
            const lines = input.trim().split('\n');
            const resultsBody = document.getElementById('wgsResultsBody');
            resultsBody.innerHTML = '';
            
            // Update table headers based on target system
            const eastingHeader = document.getElementById('eastingHeader');
            const northingHeader = document.getElementById('northingHeader');
            if (targetSystem === 'sweref99') {
                eastingHeader.textContent = 'Easting (SWEREF99)';
                northingHeader.textContent = 'Northing (SWEREF99)';
            } else {
                eastingHeader.textContent = 'Easting';
                northingHeader.textContent = 'Northing';
            }
            
            let errorMessage = '';
            let errorCount = 0;
            lines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) return;
                const parts = trimmed.split(/\s+/);
                if (parts.length < 3) {
                    errorMessage += `Line ${idx+1}: Not enough values (expected PointID Latitude Longitude)\n`;
                    errorCount++;
                    return;
                }
                const [pointID, lat, lng] = parts;
                const latNum = parseFloat(lat);
                const lngNum = parseFloat(lng);
                if (!isFinite(latNum) || !isFinite(lngNum)) {
                    errorMessage += `Line ${idx+1}: Invalid number(s)\n`;
                    errorCount++;
                    return;
                }
                try {
                    let result;
                    if (targetSystem === 'sweref99') {
                        // Convert WGS84 to SWEREF99
                        result = wgs84ToSweref99(latNum, lngNum);
                        if (!result || !result.x || !result.y) {
                            errorMessage += `Line ${idx+1}: SWEREF99 conversion failed\n`;
                            errorCount++;
                            return;
                        }
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${pointID}</td>
                            <td>${latNum.toFixed(8)}</td>
                            <td>${lngNum.toFixed(8)}</td>
                            <td>${result.x.toFixed(3)}</td>
                            <td>${result.y.toFixed(3)}</td>
                        `;
                        resultsBody.appendChild(row);
                    } else {
                        // Convert WGS84 to GK (existing functionality)
                        const pot = wgs2pot(lngNum, latNum);
                        if (!pot || !pot.lng || !pot.lat) {
                            errorMessage += `Line ${idx+1}: Datum shift failed\n`;
                            errorCount++;
                            return;
                        }
                        const gk = Dezimal2GK(pot.lng, pot.lat);
                        if (!gk || !gk.r || !gk.h) {
                            errorMessage += `Line ${idx+1}: GK conversion failed\n`;
                            errorCount++;
                            return;
                        }
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${pointID}</td>
                            <td>${latNum.toFixed(8)}</td>
                            <td>${lngNum.toFixed(8)}</td>
                            <td>${gk.r}</td>
                            <td>${gk.h}</td>
                        `;
                        resultsBody.appendChild(row);
                    }
                } catch (error) {
                    errorMessage += `Line ${idx+1}: Error converting coordinates: ${error && error.message ? error.message : error}\n`;
                    errorCount++;
                }
            });
            if (errorCount > 0) {
                alert('Errors found during conversion:\n\n' + errorMessage);
            }
        }

        function convertWGS84ToGK() {
            // Legacy function - redirect to new function
            document.getElementById('targetSystem').value = 'gk';
            convertWGS84ToTarget();
        }

        let map, vectorSource, vectorLayer;

        function initMap() {
            if (map) return;
            vectorSource = new ol.source.Vector();
            vectorLayer = new ol.layer.Vector({
                source: vectorSource
            });
            map = new ol.Map({
                target: 'mapContainer',
                layers: [
                    new ol.layer.Tile({ source: new ol.source.OSM() }),
                    vectorLayer
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([10.0, 51.0]),
                    zoom: 6
                })
            });
        }

        function updateMap() {
            if (!map || !vectorSource) return;
            vectorSource.clear();
            
            // Check all result tables for points
            let allPoints = [];
            
            // GK to WGS84 results
            const gkRows = document.querySelectorAll('#resultsBody tr');
            gkRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 6) return;
                const pointID = cells[0].textContent.trim();
                const lat = parseFloat(cells[4].textContent);
                const lng = parseFloat(cells[5].textContent);
                if (!isFinite(lat) || !isFinite(lng)) return;
                allPoints.push({ pointID, lat, lng, source: 'GK' });
            });
            
            // SWEREF99 to WGS84 results
            const swerefRows = document.querySelectorAll('#swerefResultsBody tr');
            swerefRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 6) return;
                const pointID = cells[0].textContent.trim();
                const lat = parseFloat(cells[4].textContent);
                const lng = parseFloat(cells[5].textContent);
                if (!isFinite(lat) || !isFinite(lng)) return;
                allPoints.push({ pointID, lat, lng, source: 'SWEREF99' });
            });
            
            if (allPoints.length > 0) {
                allPoints.forEach(pt => {
                    const pointFeature = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat([pt.lng, pt.lat]))
                    });
                    
                    // Different colors for different sources
                    const color = pt.source === 'SWEREF99' ? '#2196F3' : '#4CAF50';
                    
                    pointFeature.setStyle(new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 8,
                            fill: new ol.style.Fill({ color: color }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
                        })
                    }));
                    
                    const textFeature = new ol.Feature({
                        geometry: new ol.geom.Point(ol.proj.fromLonLat([pt.lng, pt.lat]))
                    });
                    textFeature.setStyle(new ol.style.Style({
                        text: new ol.style.Text({
                            text: pt.pointID,
                            font: 'bold 13px Arial',
                            fill: new ol.style.Fill({ color: '#FF9800' }),
                            stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                            offsetY: -18
                        })
                    }));
                    
                    vectorSource.addFeature(pointFeature);
                    vectorSource.addFeature(textFeature);
                });
                
                map.getView().setCenter(ol.proj.fromLonLat([allPoints[0].lng, allPoints[0].lat]));
                map.getView().setZoom(13);
            } else {
                map.getView().setCenter(ol.proj.fromLonLat([10.0, 51.0]));
                map.getView().setZoom(6);
            }
        }

        function clearInput() {
            document.getElementById('coordinates').value = '';
            document.getElementById('resultsBody').innerHTML = '';
        }

        function clearWGSInput() {
            document.getElementById('wgsCoordinates').value = '';
            document.getElementById('wgsResultsBody').innerHTML = '';
        }

        function handleWGSFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.match('text/plain')) {
                alert('Please select a text file (.txt)');
                event.target.value = '';
                return;
            }
            
            if (file.size > 5 * 1024 * 1024) {
                alert('File too large. Maximum size: 5MB');
                event.target.value = '';
                return;
            }
            
            lastImportedTxtFileName = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('wgsCoordinates').value = e.target.result;
            };
            reader.onerror = function() {
                alert('Error reading file');
                event.target.value = '';
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function saveToTxt() {
            const rows = document.querySelectorAll('#resultsBody tr');
            if (!rows.length) {
                alert('No data to save.');
                return;
            }
            
            let content = 'PointID\tEasting_GK\tNorthing_GK\tHeight\tLatitude_WGS84\tLongitude_WGS84\n';
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 6) {
                    content += `${cells[0].textContent}\t${cells[1].textContent}\t${cells[2].textContent}\t${cells[3].textContent}\t${cells[4].textContent}\t${cells[5].textContent}\n`;
                }
            });
            
            let fileName = 'gk_to_wgs84_results.txt';
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, '_converted.txt');
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                fileName = `gk_results_${dd}${mm}${yyyy}.txt`;
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function saveToPdf() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
            
            const rows = document.querySelectorAll('#resultsBody tr');
            if (!rows.length) {
                alert('No data to export.');
                return;
            }
            
            const tableData = [];
            const headers = ['PointID', 'Easting (GK)', 'Northing (GK)', 'Height', 'Latitude (WGS84)', 'Longitude (WGS84)', 'Google Maps'];

            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 7) {
                    // Google Maps link is in the 7th cell (index 6), but as an <a> element
                    let gmaps = '';
                    const link = cells[6].querySelector('a');
                    if (link) {
                        gmaps = link.href; // Full clickable URL
                    }
                    tableData.push([
                        cells[0].textContent,
                        cells[1].textContent,
                        cells[2].textContent,
                        cells[3].textContent,
                        cells[4].textContent,
                        cells[5].textContent,
                        gmaps
                    ]);
                }
            });

            doc.autoTable({
                head: [headers],
                body: tableData,
                styles: { fontSize: 8 },
                columnStyles: {
                    0: { cellWidth: 20 },
                    1: { cellWidth: 28 },
                    2: { cellWidth: 28 },
                    3: { cellWidth: 20 },
                    4: { cellWidth: 28 },
                    5: { cellWidth: 28 },
                    6: { cellWidth: 128 }
                },
                margin: { left: 10, right: 10, top: 20, bottom: 20 }
            });
            
            let fileName = 'gk_to_wgs84_results.pdf';
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, '_converted.pdf');
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                fileName = `gk_results_${dd}${mm}${yyyy}.pdf`;
            }
            
            doc.save(fileName);
        }

        function saveWGS84ToTxt() {
            const rows = document.querySelectorAll('#wgsResultsBody tr');
            if (!rows.length) {
                alert('No data to save.');
                return;
            }
            
            const targetSystem = document.getElementById('targetSystem').value;
            let content;
            
            if (targetSystem === 'sweref99') {
                content = 'PointID\tLatitude_WGS84\tLongitude_WGS84\tEasting_SWEREF99\tNorthing_SWEREF99\n';
            } else {
                content = 'PointID\tLatitude_WGS84\tLongitude_WGS84\tEasting_GK\tNorthing_GK\n';
            }
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 5) {
                    content += `${cells[0].textContent}\t${cells[1].textContent}\t${cells[2].textContent}\t${cells[3].textContent}\t${cells[4].textContent}\n`;
                }
            });
            
            let fileName;
            if (targetSystem === 'sweref99') {
                fileName = 'wgs84_to_sweref99_results.txt';
            } else {
                fileName = 'wgs84_to_gk_results.txt';
            }
            
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                const systemSuffix = targetSystem === 'sweref99' ? '_sweref99' : '_gk';
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, `${systemSuffix}_converted.txt`);
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                const systemSuffix = targetSystem === 'sweref99' ? '_sweref99' : '_gk';
                fileName = `wgs84${systemSuffix}_results_${dd}${mm}${yyyy}.txt`;
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        function saveWGS84ToPdf() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const rows = document.querySelectorAll('#wgsResultsBody tr');
            if (!rows.length) {
                alert('No data to export.');
                return;
            }
            
            const targetSystem = document.getElementById('targetSystem').value;
            let headers;
            
            if (targetSystem === 'sweref99') {
                headers = ['PointID', 'Latitude (WGS84)', 'Longitude (WGS84)', 'Easting (SWEREF99)', 'Northing (SWEREF99)'];
            } else {
                headers = ['PointID', 'Latitude (WGS84)', 'Longitude (WGS84)', 'Easting (GK)', 'Northing (GK)'];
            }
            
            const tableData = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length >= 5) {
                    tableData.push([
                        cells[0].textContent,
                        cells[1].textContent,
                        cells[2].textContent,
                        cells[3].textContent,
                        cells[4].textContent
                    ]);
                }
            });
            
            doc.autoTable({
                head: [headers],
                body: tableData,
                styles: { fontSize: 8 },
                columnStyles: {
                    0: { cellWidth: 20 },
                    1: { cellWidth: 30 },
                    2: { cellWidth: 30 },
                    3: { cellWidth: 20 },
                    4: { cellWidth: 30 }
                }
            });
            
            let fileName;
            if (targetSystem === 'sweref99') {
                fileName = 'wgs84_to_sweref99_results.pdf';
            } else {
                fileName = 'wgs84_to_gk_results.pdf';
            }
            
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                const systemSuffix = targetSystem === 'sweref99' ? '_sweref99' : '_gk';
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, `${systemSuffix}_converted.pdf`);
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                const systemSuffix = targetSystem === 'sweref99' ? '_sweref99' : '_gk';
                fileName = `wgs84${systemSuffix}_results_${dd}${mm}${yyyy}.pdf`;
            }
            
            doc.save(fileName);
        }

        function convertCoordinates() {
            const input = document.getElementById('coordinates').value;
            const lines = input.trim().split('\n');
            const resultsBody = document.getElementById('resultsBody');
            resultsBody.innerHTML = '';
            let errorMessage = '';
            let errorCount = 0;
            lines.forEach((line, idx) => {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) return;
                const parts = trimmed.split(/\s+/);
                if (parts.length < 4) {
                    errorMessage += `Line ${idx+1}: Not enough values (expected PointID Easting Northing Height)\n`;
                    errorCount++;
                    return;
                }
                const [pointID, x, y, height] = parts;
                const xNum = parseFloat(x);
                const yNum = parseFloat(y);
                const hNum = parseFloat(height);
                if (!isFinite(xNum) || !isFinite(yNum) || !isFinite(hNum)) {
                    errorMessage += `Line ${idx+1}: Invalid number(s)\n`;
                    errorCount++;
                    return;
                }
                try {
                    const { lat, lng } = gk2geo(xNum, yNum);
                    const row = document.createElement('tr');
                    const mapsLink = getGoogleMapsLink(lat, lng);
                    row.innerHTML = `
                        <td>${pointID}</td>
                        <td>${xNum.toFixed(3)}</td>
                        <td>${yNum.toFixed(3)}</td>
                        <td>${hNum.toFixed(3)}</td>
                        <td>${lat.toFixed(6)}</td>
                        <td>${lng.toFixed(6)}</td>
                        <td><a href="${mapsLink}" target="_blank" class="map-link">View on Map</a></td>
                    `;
                    resultsBody.appendChild(row);
                } catch (error) {
                    errorMessage += `Line ${idx+1}: Error converting coordinates: ${error && error.message ? error.message : error}\n`;
                    errorCount++;
                }
            });
            if (errorCount > 0) {
                alert('Errors found during conversion:\n\n' + errorMessage);
            }
            if (typeof initMap === 'function') {
                initMap();
            }
            if (typeof updateMap === 'function') {
                updateMap();
            }
        }

        function getGoogleMapsLink(lat, lon) {
            return `https://maps.google.com/?q=${lat},${lon}`;
        }

        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const tabButtons = document.querySelectorAll('.tab');
            tabButtons.forEach(tab => {
                if (tab.getAttribute('onclick') && tab.getAttribute('onclick').includes(tabId)) {
                    tab.classList.add('active');
                }
            });
            if (tabId === 'map') {
                initMap();
                updateMap();
            }
        }

        let lastImportedTxtFileName = null;

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (!file.type.match('text/plain')) {
                alert('Please select a text file (.txt)');
                event.target.value = '';
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                alert('File too large. Maximum size: 5MB');
                event.target.value = '';
                return;
            }
            lastImportedTxtFileName = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                document.getElementById('coordinates').value = e.target.result;
            };
            reader.onerror = function() {
                alert('Error reading file');
                event.target.value = '';
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function saveMapToPdf() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });
            const mapContainer = document.getElementById('mapContainer');
            const quality = parseFloat(document.getElementById('pdfQuality').value);
            html2canvas(mapContainer).then(canvas => {
                const imgData = canvas.toDataURL('image/jpeg', quality);
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;
                let renderWidth = pageWidth;
                let renderHeight = (imgHeight * pageWidth) / imgWidth;
                if (renderHeight > pageHeight) {
                    renderHeight = pageHeight;
                    renderWidth = (imgWidth * pageHeight) / imgHeight;
                }
                const x = (pageWidth - renderWidth) / 2;
                const y = (pageHeight - renderHeight) / 2;
                doc.addImage(imgData, 'JPEG', x, y, renderWidth, renderHeight);
                doc.save('map.pdf');
            });
        }

        function exportKML() {
            // Collect points from all result tables
            let allPoints = [];
            
            // GK to WGS84 results
            const gkRows = document.querySelectorAll('#resultsBody tr');
            gkRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 6) return;
                const pointID = cells[0].textContent.trim();
                const lat = parseFloat(cells[4].textContent);
                const lng = parseFloat(cells[5].textContent);
                if (!isFinite(lat) || !isFinite(lng)) return;
                allPoints.push({ pointID: pointID, lat, lng });
            });
            
            // SWEREF99 to WGS84 results
            const swerefRows = document.querySelectorAll('#swerefResultsBody tr');
            swerefRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 6) return;
                const pointID = cells[0].textContent.trim();
                const lat = parseFloat(cells[4].textContent);
                const lng = parseFloat(cells[5].textContent);
                if (!isFinite(lat) || !isFinite(lng)) return;
                allPoints.push({ pointID: pointID, lat, lng });
            });
            
            if (!allPoints.length) {
                alert('No points to export.');
                return;
            }
            
            let kml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            kml += `<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n`;
            
            allPoints.forEach(point => {
                kml += `<Placemark>\n`;
                kml += `<name>${point.pointID}</name>\n`;
                kml += `<Point><coordinates>${point.lng},${point.lat},0</coordinates></Point>\n`;
                kml += `</Placemark>\n`;
            });
            
            kml += `</Document>\n</kml>`;
            
            let fileName = 'points.kml';
            if (lastImportedTxtFileName && lastImportedTxtFileName.toLowerCase().endsWith('.txt')) {
                fileName = lastImportedTxtFileName.replace(/\.txt$/i, '.kml');
            } else {
                const now = new Date();
                const dd = String(now.getDate()).padStart(2, '0');
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const yyyy = now.getFullYear();
                fileName = `${dd}${mm}${yyyy}.kml`;
            }
            
            const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        }

        (function() {
            document.addEventListener('DOMContentLoaded', function() {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        if (this.getAttribute('onclick') && this.getAttribute('onclick').includes('map')) {
                            setTimeout(initMap, 100);
                        }
                    });
                });
                const slider = document.getElementById('pdfQuality');
                const valueSpan = document.getElementById('pdfQualityValue');
                if (slider && valueSpan) {
                    slider.addEventListener('input', function() {
                        valueSpan.textContent = slider.value;
                    });
                }
            });
        })();
    </script>
</body>
</html>
